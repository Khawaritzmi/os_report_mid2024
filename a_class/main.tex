\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}

\title{Operating System Course Report - First Half of the Semester}
\author{A class}
\date{\today}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}
This report summarizes the topics covered during the first half of the Operating System course. It includes theoretical concepts, practical implementations, and assignments. The course focuses on the fundamentals of operating systems, including system architecture, process management, CPU scheduling, and deadlock handling.

\section{Course Overview}
\subsection{Objectives}
The main objectives of this course are:
\begin{itemize}
    \item To understand the basic components and architecture of a computer system.
    \item To learn process management, scheduling, and inter-process communication.
    \item To explore file systems, input/output management, and virtualization.
    \item To study the prevention and handling of deadlocks in operating systems.
\end{itemize}

\subsection{Course Structure}
The course is divided into two halves. This report focuses on the first half, which covers:
\begin{itemize}
    \item Basic Concepts and Components of Computer Systems
    \item System Performance and Metrics
    \item System Architecture of Computer Systems
    \item Process Description and Control
    \item Scheduling Algorithms
    \item Process Creation and Termination
    \item Introduction to Threads
    \item File Systems
    \item Input and Output Management
    \item Deadlock Introduction and Prevention
    \item User Interface Management
    \item Virtualization in Operating Systems
\end{itemize}

\section{Topics Covered}

\subsection{Basic Concepts and Components of Computer Systems}
This section explains the fundamental components that make up a computer system, including the CPU, memory, storage, and input/output devices.

\subsection{System Performance and Metrics}
This section introduces various system performance metrics used to measure the efficiency of a computer system, including throughput, response time, and utilization.

\subsection{System Architecture of Computer Systems}
Describes the architecture of modern computer systems, focusing on the interaction between hardware and the operating system.

\subsection{Process Description and Control}
Processes are a central concept in operating systems. This section covers:
\begin{itemize}
    \item Process states and state transitions
    \item Process control block (PCB)
    \item Context switching
\end{itemize}

\subsection{Scheduling Algorithms}
This section covers:
\begin{itemize}
    \item First-Come, First-Served (FCFS)
    \item Shortest Job Next (SJN)
    \item Round Robin (RR)
\end{itemize}
It explains how these algorithms are used to allocate CPU time to processes.

\subsection{Process Creation and Termination}
Details how processes are created and terminated by the operating system, including:
\begin{itemize}
    \item Process spawning
    \item Process termination conditions
\end{itemize}

\subsection{Introduction to Threads}
This section introduces the concept of threads and their relation to processes, covering:
\begin{itemize}
    \item Konsep Threads
    \item Hubungan antara Threads dan Proses
    \item Manfaat Penggunaan Threads
    \item Multithreading
    \item Threads vs Process
    \item Model Multithreading
    \item Pengelolaan Threads
    \item Penerapan Threads pada Sistem Operasi
\end{itemize}
\subsubsection{Konsep Threads}
\subsubsection{Hubungan antara Threads dan Proses}
\subsubsection{Manfaat Penggunaan Threads}
Beberapa manfaat utama dari \textit{multithreading} meliputi:
\begin{itemize}
    \item Peningkatan kinerja dan efisiensi:
    \begin{itemize}
        \item \textit{Multithreading} memungkinkan eksekusi beberapa tugas secara bersamaan dengan memanfaatkan sumber daya \textit{CPU} secara lebih optimal. Ketika sebuah program berjalan dalam mode satu \textit{thread} (dikenal sebagai \textit{single-threading}), prosesor hanya dapat menangani satu tugas pada satu waktu. Namun, dengan \textit{multithreading}, beberapa \textit{threads} dapat berjalan dalam waktu yang sama, memanfaatkan kemampuan inti prosesor untuk menangani lebih dari satu operasi. Misalnya, dalam aplikasi grafis, satu \textit{thread} dapat menangani rendering objek, sementara \textit{thread} lain menangani input pengguna.
        \item Pada sistem dengan \textit{multiprosesor} atau \textit{multi-core}, \textit{threads} dapat berjalan secara paralel, yang artinya setiap inti prosesor dapat menangani \textit{thread} yang berbeda. Misalnya, jika sebuah komputer memiliki empat inti prosesor, ia dapat menjalankan empat \textit{threads} secara paralel, yang meningkatkan kemampuan komputer untuk menyelesaikan pekerjaan lebih cepat. Ini sangat berguna untuk aplikasi yang membutuhkan banyak komputasi seperti pemrosesan data besar, aplikasi \textit{machine learning}, atau aplikasi \textit{scientific computing}. Selain itu, \textit{throughput}, atau jumlah tugas yang bisa diselesaikan dalam satu waktu, juga akan meningkat secara signifikan dengan adanya pemrosesan paralel ini.
    \end{itemize}
    
    \item Responsivitas aplikasi yang lebih baik:
    \begin{itemize}
        \item Aplikasi yang memanfaatkan \textit{multithreading} cenderung lebih responsif terhadap input pengguna meskipun ada tugas berat yang sedang berjalan di latar belakang. Misalnya, dalam sebuah program pengeditan video, satu \textit{thread} dapat terus menjalankan tugas rendering, sementara \textit{thread} lain tetap menerima input pengguna seperti pemotongan video atau perubahan filter. Pengguna tidak akan merasa aplikasi "terkunci" atau "membeku", karena proses rendering dan interaksi pengguna dapat berjalan secara bersamaan.
        \item Dengan adanya \textit{multithreading}, aplikasi dapat mencegah terjadinya \textit{bottleneck} atau kemacetan dalam menjalankan berbagai tugas yang memakan waktu lama. Sebagai contoh, saat aplikasi sedang melakukan pengunduhan file besar, alih-alih harus menunggu hingga pengunduhan selesai, aplikasi masih dapat merespons input pengguna seperti membuka menu, melakukan tugas lainnya, atau menampilkan informasi progres pengunduhan dalam waktu nyata. Ini sangat membantu dalam memberikan pengalaman pengguna yang lebih baik.
    \end{itemize}
    
    \item Penggunaan sumber daya yang lebih efisien:
    \begin{itemize}
        \item \textit{Threads} dalam satu proses berbagi memori dan sumber daya lainnya, membuat penggunaan memori menjadi lebih efisien dibandingkan menjalankan beberapa proses yang terpisah. Jika setiap tugas dilakukan dalam proses terpisah, sistem harus menyediakan ruang memori dan sumber daya lainnya untuk masing-masing proses, yang tentu saja membutuhkan lebih banyak overhead. Namun, dengan \textit{threads}, overhead ini dapat dikurangi karena mereka berbagi ruang memori yang sama.
        \item Selain itu, karena \textit{threads} berbagi ruang memori, pertukaran informasi di antara mereka jauh lebih cepat dibandingkan jika menggunakan proses terpisah yang memerlukan mekanisme komunikasi antar-proses (\textit{IPC}). Dalam aplikasi yang sering membutuhkan pembagian data antar-tugas, seperti aplikasi basis data atau sistem transaksi, efisiensi komunikasi antar-\textit{threads} ini sangat penting untuk menjaga kinerja dan responsivitas yang optimal.
        \item Sebagai contoh, bayangkan sebuah sistem pemrosesan transaksi di mana satu \textit{thread} bertugas membaca data transaksi dari basis data, sementara \textit{thread} lain memverifikasi transaksi tersebut. Karena keduanya berbagi ruang memori, data transaksi yang dibaca tidak perlu disalin dari satu \textit{thread} ke \textit{thread} lain, yang menghemat waktu dan memori. Dalam skala besar, penghematan ini bisa sangat signifikan.
    \end{itemize}
    
    \item Penyederhanaan desain program:
    \begin{itemize}
        \item Dengan menggunakan \textit{multithreading}, pengembang dapat membagi tugas besar menjadi tugas-tugas kecil yang dijalankan dalam \textit{threads} terpisah, menyederhanakan struktur program secara keseluruhan. Misalnya, dalam aplikasi permainan video, satu \textit{thread} dapat bertugas untuk menangani fisika objek, sementara \textit{thread} lain bertugas untuk mengelola AI karakter, dan \textit{thread} lain mengurus rendering grafis. Dengan membagi tugas-tugas ini ke dalam \textit{threads} terpisah, pengembangan dan pemeliharaan program menjadi lebih mudah karena setiap \textit{thread} dapat difokuskan pada satu tugas spesifik.
        \item Selain itu, \textit{threads} juga memudahkan pengelolaan beberapa tugas secara bersamaan tanpa mempersulit desain program secara keseluruhan. Setiap \textit{thread} dapat dikembangkan, diuji, dan dikelola secara independen dari \textit{threads} lain, mengurangi kerumitan kode dan menghindari potensi kesalahan dalam sinkronisasi tugas.
        \item Misalnya, dalam aplikasi e-commerce yang kompleks, satu \textit{thread} dapat menangani pemrosesan pesanan, sementara yang lain menangani verifikasi pembayaran, dan \textit{thread} ketiga menangani pengiriman. Desain terpisah semacam ini memudahkan pengembang untuk memisahkan logika bisnis yang berbeda dan memastikan setiap bagian program berfungsi dengan benar secara terisolasi.
    \end{itemize}
    
    \item Komunikasi antar-\textit{threads} yang efisien:
    \begin{itemize}
        \item Dalam sebuah proses yang menjalankan banyak \textit{threads}, komunikasi antar-\textit{threads} dapat dilakukan lebih efisien karena mereka berbagi ruang memori yang sama. Misalnya, jika satu \textit{thread} menghasilkan data yang dibutuhkan oleh \textit{thread} lain, data tersebut dapat diakses langsung tanpa perlu disalin ke memori terpisah. Hal ini berbeda dengan proses yang terpisah, yang membutuhkan mekanisme seperti soket atau saluran komunikasi yang memperlambat interaksi antar proses.
        \item Keuntungan dari komunikasi antar-\textit{threads} yang lebih efisien ini sangat penting dalam aplikasi yang membutuhkan sinkronisasi cepat antar tugas, seperti aplikasi server yang menangani banyak permintaan pengguna secara bersamaan. Sebagai contoh, sebuah server web dapat memiliki satu \textit{thread} yang menangani permintaan pengguna, sementara \textit{thread} lain mengumpulkan data dari basis data. Kedua \textit{threads} dapat berkomunikasi dengan cepat untuk memberikan respons yang lebih cepat kepada pengguna.
    \end{itemize}
    
    \item Skalabilitas yang lebih baik:
    \begin{itemize}
        \item Program yang dirancang dengan \textit{multithreading} dapat lebih mudah diskalakan untuk memanfaatkan sistem dengan lebih banyak inti prosesor. Misalnya, pada sistem dengan banyak inti prosesor, \textit{threads} tambahan dapat dijalankan secara paralel untuk meningkatkan efisiensi pemrosesan. Ini sangat bermanfaat dalam server modern yang harus menangani ribuan pengguna sekaligus. Dengan menambahkan lebih banyak \textit{threads}, server dapat menangani lebih banyak permintaan tanpa menurunkan kinerja.
        \item Selain itu, program berbasis \textit{multithreading} cenderung lebih siap untuk beradaptasi dengan teknologi perangkat keras baru. Dengan penambahan prosesor atau sumber daya lainnya, program tersebut dapat diubah dan dikembangkan tanpa harus mendesain ulang keseluruhan struktur program. Hal ini memungkinkan pengembangan aplikasi yang lebih berkelanjutan dan mudah ditingkatkan di masa depan.
    \end{itemize}
    
    \item Pemanfaatan waktu tunggu \textit{I/O}:
    \begin{itemize}
        \item Dalam banyak kasus, operasi \textit{I/O} (seperti membaca atau menulis file, atau berkomunikasi dengan jaringan) memakan waktu lebih lama dibandingkan operasi komputasi biasa. Dengan \textit{multithreading}, satu \textit{thread} dapat melanjutkan pemrosesan tugas lain sementara menunggu hasil dari operasi \textit{I/O}, sehingga sistem tidak dibiarkan menganggur. Ini meningkatkan efisiensi penggunaan waktu dan sumber daya.
        \item Sebagai contoh, dalam aplikasi berbasis web, sementara satu \textit{thread} menunggu respons dari server jarak jauh, \textit{threads} lain dapat melanjutkan pemrosesan data lokal atau menampilkan informasi kepada pengguna. Dengan demikian, pengguna tidak perlu menunggu hingga semua tugas selesai sebelum melanjutkan interaksi dengan aplikasi.
    \end{itemize}
    
    \item Cocok untuk aplikasi \textit{server}:
    \begin{itemize}
        \item Aplikasi server seperti server web atau server database sangat diuntungkan dari \textit{multithreading} karena harus menangani banyak permintaan klien secara bersamaan. Alih-alih membuat satu proses terpisah untuk setiap klien (yang akan memakan banyak memori dan sumber daya sistem), server dapat menggunakan \textit{threads} untuk menangani setiap koneksi klien secara lebih efisien. Setiap klien dapat dilayani oleh satu atau beberapa \textit{threads}, memungkinkan server untuk memproses permintaan dengan cepat tanpa kelebihan beban.
        \item Selain itu, \textit{multithreading} juga memungkinkan server untuk tetap responsif meskipun beban kerja meningkat. Misalnya, server dapat memulai \textit{threads} baru untuk menangani permintaan klien tambahan tanpa memengaruhi kinerja \textit{threads} yang sudah ada. Ini memastikan bahwa server dapat menangani lebih banyak klien sekaligus tanpa mengorbankan kualitas layanan.
    \end{itemize}
\end{itemize}

\subsubsection{Multithreading}
\subsubsection{Threads vs Process}
\subsubsection{Model Multithreading}
\subsubsection{Pengelolaan Threads}
\subsubsection{Penerapan Threads pada Sistem Operasi}


\subsection{File Systems}
File systems provide a way for the operating system to store, retrieve, and manage data. This section explains:
\begin{itemize}
    \item File system structure
    \item File access methods
    \item Directory management
\end{itemize}

\subsection{Input and Output Management}
Input and output management is key for handling the interaction between the system and external devices. This section includes:
\begin{itemize}
    \item Device drivers
    \item I/O scheduling
\end{itemize}

\subsection{Deadlock Introduction and Prevention}
Explores the concept of deadlocks and methods for preventing them:
\begin{itemize}
    \item Deadlock conditions
    \item Deadlock prevention techniques
\end{itemize}

\subsection{User Interface Management}
This section discusses the role of the operating system in managing the user interface. Topics covered include:
\begin{itemize}
    \item Graphical User Interface (GUI)
    \item Command-Line Interface (CLI)
    \item Interaction between the user and the operating system
\end{itemize}

\subsection{Virtualization in Operating Systems}
Virtualization allows multiple operating systems to run concurrently on a single physical machine. This section explores:
\begin{itemize}
    \item Concept of virtualization
    \item Hypervisors and their types
    \item Benefits of virtualization in modern computing
\end{itemize}

\section{Assignments and Practical Work}
\subsection{Assignment 1: Process Scheduling}
Students were tasked with implementing various process scheduling algorithms (e.g., FCFS, SJN, and RR) and comparing their performance under different conditions.

\subsection{Assignment 2: Deadlock Handling}
In this assignment, students were asked to simulate different deadlock scenarios and explore various prevention methods.

\subsection{Assignment 3: Multithreading and Amdahl's Law}
This assignment involved designing a multithreading scenario to solve a computationally intensive problem. Students then applied **Amdahl's Law** to calculate the theoretical speedup of the program as the number of threads increased.

\subsection{Assignment 4: Simple Command-Line Interface (CLI) for User Interface Management}
Students were tasked with creating a simple **CLI** for user interface management. The CLI should support basic commands such as file manipulation (creating, listing, and deleting files), process management, and system status reporting.

\subsection{Assignment 5: File System Access}
In this assignment, students implemented file system access routines, including:
\begin{itemize}
    \item File creation and deletion
    \item Reading from and writing to files
    \item Navigating directories and managing file permissions
\end{itemize}

\section{Conclusion}
The first half of the course introduced core operating system concepts, including process management, scheduling, multithreading, and file system access. These topics provided a foundation for more advanced topics to be covered in the second half of the course.

\end{document}