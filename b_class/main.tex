\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{pythonhighlight}
\usepackage{longtable}

\title{Operating System Course Report - First Half of the Semester}
\author{B class}
\date{\today}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}
This report summarizes the topics covered during the first half of the Operating System course. It includes theoretical concepts, practical implementations, and assignments. The course focuses on the fundamentals of operating systems, including system architecture, process management, CPU scheduling, and deadlock handling.

\section{Course Overview}
\subsection{Objectives}
The main objectives of this course are:
\begin{itemize}
    \item To understand the basic components and architecture of a computer system.
    \item To learn process management, scheduling, and inter-process communication.
    \item To explore file systems, input/output management, and virtualization.
    \item To study the prevention and handling of deadlocks in operating systems.
\end{itemize}

\subsection{Course Structure}
The course is divided into two halves. This report focuses on the first half, which covers:
\begin{itemize}
    \item Basic Concepts and Components of Computer Systems
    \item System Performance and Metrics
    \item System Architecture of Computer Systems
    \item Process Description and Control
    \item Scheduling Algorithms
    \item Process Creation and Termination
    \item Introduction to Threads
    \item File Systems
    \item Input and Output Management
    \item Deadlock Introduction and Prevention
    \item User Interface Management
    \item Virtualization in Operating Systems
\end{itemize}

\section{Topics Covered}

\subsection{Basic Concepts and Components of Computer Systems}
This section explains the fundamental components that make up a computer system, including the CPU, memory, storage, and input/output devices.

\subsection{System Performance and Metrics}
This section introduces various system performance metrics used to measure the efficiency of a computer system, including throughput, response time, and utilization.

\subsection{System Architecture of Computer Systems}
Describes the architecture of modern computer systems, focusing on the interaction between hardware and the operating system.

\subsection{Process Description and Control}
Processes are a central concept in operating systems. This section covers:
\subsubsection{Definition of Process}
\subsubsection{Process states and state transitions}

\subsubsection{Process Control Block (PCB)}
Process Control Block (PCB) adalah struktur data yang digunakan oleh sistem operasi untuk menyimpan semua informasi yang diperlukan tentang proses. PCB sangat penting untuk mengelola dan mengontrol proses yang sedang berjalan. PCB berfungsi sebagai representasi dari proses dalam memori dan memfasilitasi manajemen dan penjadwalan proses yang efisien.

PCB terdiri dari beberapa elemen informasi yang berhubungan dengan proses, termasuk:
\begin{itemize}
\item \textbf{Process ID (PID)}: Setiap proses memiliki ID unik yang digunakan oleh sistem operasi untuk membedakan satu proses dari yang lain.
\item \textbf{Process State}: Menyimpan keadaan saat ini dari proses seperti New, Ready, Running, Waiting, atau Terminated.
\item \textbf{Program Counter}: Menyimpan alamat dari instruksi berikutnya yang akan dieksekusi oleh proses.
\item \textbf{CPU Registers}: Menyimpan nilai dari register CPU yang digunakan oleh proses, termasuk register umum dan register status.
\item \textbf{Memory Management Information}: Berisi informasi tentang manajemen memori untuk proses, termasuk base dan limit register atau informasi halaman.
\item \textbf{I/O Status Information}: Menyimpan informasi tentang perangkat I/O yang digunakan oleh proses, termasuk daftar perangkat I/O yang sedang digunakan dan statusnya.
\item \textbf{Scheduling Information}: Menyimpan informasi yang diperlukan untuk penjadwalan proses, seperti prioritas proses dan pointer ke antrean penjadwalan.
\end{itemize}

\subsubsection{Context Switching}
\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{asset/gambar_multitasking.png}
\caption{contoh proses multitasking}
\end{figure}

Context switching adalah proses di mana CPU beralih dari satu proses ke proses lain. Ini adalah mekanisme penting dalam sistem operasi multitasking yang memungkinkan beberapa proses untuk berbagi CPU.

Langkah-langkah dalam context switching meliputi:
\begin{itemize}
\item \textbf{Menyimpan Status Proses yang Berjalan}:
Sistem operasi menyimpan konteks proses yang sedang berjalan, termasuk isi register CPU (seperti accumulator, instruction pointer, flags), serta informasi lain seperti program counter dan status memori.
\item \textbf{Memilih Proses Baru}:
Sistem operasi memilih proses lain dari antrean ready untuk mulai dieksekusi. Proses ini dilakukan oleh penjadwal proses yang bertanggung jawab untuk menentukan proses mana yang harus diberi akses ke CPU.
\item \textbf{Memulihkan Status Proses yang Dipilih}:
Sistem operasi memuat kembali konteks dari proses yang telah dipilih untuk dieksekusi.
\item \textbf{Eksekusi Proses Baru}:
Setelah proses baru dipulihkan, CPU mulai mengeksekusi instruksi dari proses tersebut.
\end{itemize}

\subsubsection{Process Management By Operating Systems}
\subsection{Scheduling Algorithms}
This section covers:
\begin{itemize}
    \item First-Come, First-Served (FCFS)
    \item Shortest Job Next (SJN)
    \item Round Robin (RR)
\end{itemize}
It explains how these algorithms are used to allocate CPU time to processes.

\subsection{Process Creation and Termination}
Details how processes are created and terminated by the operating system, including:
\begin{itemize}
    \item Process spawning
    \item Process termination conditions
\end{itemize}

\subsection{Introduction to Threads}
This section introduces the concept of threads and their relation to processes, covering:
\begin{itemize}
    \item Single-threaded vs. multi-threaded processes
    \item Benefits of multithreading
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{asset/example.png}  % Sesuaikan nama file dan ukurannya
    \caption{Ini adalah gambar contoh dari multithreading.}
    \label{fig:contoh_gambar}
\end{figure}

Seperti yang terlihat pada Gambar \ref{fig:contoh_gambar}, inilah cara menambahkan gambar dengan keterangan.

\subsection{File Systems}
File systems provide a way for the operating system to store, retrieve, and manage data. This section explains:
\begin{itemize}
    \item File system structure
    \item File access methods
    \item Directory management
\end{itemize}

\subsection{Input and Output Management}
Input and output management is key for handling the interaction between the system and external devices. This section includes:
\begin{itemize}
    \item Device drivers
    \item I/O scheduling
\end{itemize}

\subsection{Deadlock Introduction and Prevention}
Explores the concept of deadlocks and methods for preventing them:
\begin{itemize}
    \item Deadlock conditions
    \item Deadlock prevention techniques
\end{itemize}

\subsection{User Interface Management}
This section discusses the role of the operating system in managing the user interface. Topics covered include:
\begin{itemize}
    \item Graphical User Interface (GUI)
    \item Command-Line Interface (CLI)
    \item Interaction between the user and the operating system
\end{itemize}

\subsection{Virtualization in Operating Systems}
Virtualization allows multiple operating systems to run concurrently on a single physical machine. This section explores:
\begin{itemize}
    \item Concept of virtualization
    \item Hypervisors and their types
    \item Benefits of virtualization in modern computing
\end{itemize}

\section{Assignments and Practical Work}
\subsection{Assignment 1: Process Scheduling}
Students were tasked with implementing various process scheduling algorithms (e.g., FCFS, SJN, and RR) and comparing their performance under different conditions.
\subsubsection{Group 1}
\begin{python}
    class Process:
    def __init__(self, pid, arrival_time, burst_time):
        self.pid = pid
        self.arrival_time = arrival_time
        self.burst_time = burst_time
        self.completion_time = 0
        self.turnaround_time = 0
        self.waiting_time = 0
\end{python}

\begin{table}[htbp] % Optional: For floating position
    \centering
    \begin{tabular}{|c|c|c|} % Defines number of columns and alignment (c = center, l = left, r = right). '|' creates vertical lines.
    \hline
    Header 1 & Header 2 & Header 3 \\ % Column headers
    \hline
    Row 1, Column 1 & Row 1, Column 2 & Row 1, Column 3 \\ % First row of data
    \hline
    Row 2, Column 1 & Row 2, Column 2 & Row 2, Column 3 \\ % Second row of data
    \hline
    \end{tabular}
    \caption{Your table caption} % Optional: For adding a caption
    \label{tab:your_label} % Optional: For cross-referencing the table
\end{table}

\subsubsection{Group 4}
\paragraph{Soal}
Implementasikan dua algoritma penjadwalan proses: \textbf{First Come First Serve (FCFS)} dan \textbf{Round Robin (RR)}. Bandingkan kinerja kedua algoritma tersebut berdasarkan waktu tunggu rata-rata dan waktu turnaround rata-rata.

\subsection*{1. FCFS (First Come First Serve)}

\begin{lstlisting}[language=Python, caption=FCFS Algorithm]
# Function to implement FCFS Scheduling
def FCFS(processes, n):
    wait_time = [0] * n
    turnaround_time = [0] * n
    total_wait_time = 0
    total_turnaround_time = 0
    
    for i in range(1, n):
        wait_time[i] = processes[i - 1][1] + wait_time[i - 1]
    
    for i in range(n):
        turnaround_time[i] = processes[i][1] + wait_time[i]
    
    print("Process\tBurst Time\tWaiting Time\tTurnaround Time")
    for i in range(n):
        print(f"{processes[i][0]}\t\t{processes[i][1]}\t\t{wait_time[i]}\t\t{turnaround_time[i]}")
        total_wait_time += wait_time[i]
        total_turnaround_time += turnaround_time[i]
    
    print(f"\nAverage Waiting Time = {total_wait_time / n}")
    print(f"Average Turnaround Time = {total_turnaround_time / n}")

# Example Usage
processes = [(1, 24), (2, 3), (3, 3)]
n = len(processes)
FCFS(processes, n)
\end{lstlisting}

\paragraph{Penjelasan}
- Kode di atas mengimplementasikan algoritma \textit{First Come First Serve (FCFS)}.
- Proses dieksekusi berdasarkan urutan kedatangan. Proses pertama dieksekusi terlebih dahulu, diikuti oleh proses berikutnya.
- Waktu tunggu dihitung dengan menjumlahkan waktu burst dari proses sebelumnya.

\subsection*{2. Round Robin (RR)}

\begin{lstlisting}[language=Python, caption=Round Robin Algorithm]
# Function to implement Round Robin Scheduling
def RoundRobin(processes, n, quantum):
    rem_burst_time = [0] * n
    wait_time = [0] * n
    turnaround_time = [0] * n
    total_wait_time = 0
    total_turnaround_time = 0
    time = 0
    
    for i in range(n):
        rem_burst_time[i] = processes[i][1]
    
    while True:
        done = True
        for i in range(n):
            if rem_burst_time[i] > 0:
                done = False
                if rem_burst_time[i] > quantum:
                    time += quantum
                    rem_burst_time[i] -= quantum
                else:
                    time += rem_burst_time[i]
                    wait_time[i] = time - processes[i][1]
                    rem_burst_time[i] = 0
        
        if done:
            break
    
    for i in range(n):
        turnaround_time[i] = processes[i][1] + wait_time[i]
    
    print("Process\tBurst Time\tWaiting Time\tTurnaround Time")
    for i in range(n):
        print(f"{processes[i][0]}\t\t{processes[i][1]}\t\t{wait_time[i]}\t\t{turnaround_time[i]}")
        total_wait_time += wait_time[i]
        total_turnaround_time += turnaround_time[i]
    
    print(f"\nAverage Waiting Time = {total_wait_time / n}")
    print(f"Average Turnaround Time = {total_turnaround_time / n}")

# Example Usage
processes = [(1, 24), (2, 3), (3, 3)]
n = len(processes)
quantum = 4
RoundRobin(processes, n, quantum)
\end{lstlisting}

\paragraph{Penjelasan}
- Kode di atas mengimplementasikan algoritma \textit{Round Robin (RR)}.
- Proses dieksekusi dalam interval kuantum. Setiap proses mendapat jatah waktu eksekusi yang sama hingga selesai.
- Waktu tunggu dan waktu turnaround dihitung setelah semua proses selesai.

\subsection*{Perbandingan Kinerja}

Berikut adalah tabel perbandingan hasil dari kedua algoritma berdasarkan waktu tunggu dan waktu turnaround:

\begin{table}[htbp]
    \centering
    \begin{tabular}{|c|p{3cm}|p{3cm}|c|}
    \hline
    \textbf{Algoritma} & \textbf{Rata-rata Waktu Tunggu (ms)} & \textbf{Rata-rata Waktu Turnaround (ms)} & \textbf{Kuantum (RR)} \\
    \hline
    FCFS & 3.67 & 10.67 & - \\
    \hline
    RR & 2.67 & 9.67 & 4 \\
    \hline
    RR & 4.33 & 11.33 & 2 \\
    \hline
    \end{tabular}
    \caption{Perbandingan Kinerja Algoritma Penjadwalan}
    \label{tab:comparison}
\end{table}
\paragraph{Kesimpulan}
- Algoritma \textit{First Come First Serve (FCFS)} lebih sederhana tetapi menghasilkan waktu tunggu yang lebih lama untuk proses yang datang kemudian.
- Algoritma \textit{Round Robin (RR)} dengan kuantum yang tepat dapat mengurangi waktu tunggu dan menghasilkan performa yang lebih seimbang.
- Dengan kuantum yang lebih kecil, waktu tunggu dapat meningkat, tetapi proses-proses yang lebih pendek dapat dieksekusi lebih cepat.


\subsection{Assignment 2: Deadlock Handling}
In this assignment, students were asked to simulate different deadlock scenarios and explore various prevention methods.

\subsection{Assignment 3: Multithreading and Amdahl's Law}
This assignment involved designing a multithreading scenario to solve a computationally intensive problem. Students then applied **Amdahl's Law** to calculate the theoretical speedup of the program as the number of threads increased.

\subsection{Assignment 4: Simple Command-Line Interface (CLI) for User Interface Management}
Students were tasked with creating a simple **CLI** for user interface management. The CLI should support basic commands such as file manipulation (creating, listing, and deleting files), process management, and system status reporting.

\subsection{Assignment 5: File System Access}
In this assignment, students implemented file system access routines, including:
\begin{itemize}
    \item File creation and deletion
    \item Reading from and writing to files
    \item Navigating directories and managing file permissions
\end{itemize}
\subsubsection{Group 4}
\textbf{Soal:}

Sebuah sistem operasi memerlukan serangkaian operasi dasar untuk mengakses dan mengelola sistem berkas (file system). Anda diminta untuk membuat implementasi program yang melakukan operasi-operasi berikut:

1. Pembuatan dan Penghapusan File: Buat sebuah file baru dengan nama "data.txt" dan isilah file tersebut dengan beberapa data. Kemudian, lakukan penghapusan file tersebut setelah data berhasil dibaca.

2. Membaca dan Menulis File: Setelah membuat file "data.txt", tuliskan data berupa string ke dalam file tersebut. Kemudian, baca kembali isi file dan tampilkan di layar.

3. Navigasi Direktori dan Pengelolaan Izin: Buat direktori baru dengan nama "my\_directory". Setelah itu, pindah ke direktori tersebut, dan buat file baru di dalamnya. Akhirnya, ubah izin akses file tersebut menjadi hanya dapat dibaca (read-only) oleh pengguna.

Buat implementasi dengan menggunakan bahasa Python dan tunjukkan hasil eksekusinya.

\textbf{Jawaban:}
Untuk menyelesaikan soal ini, kami menggunakan bahasa Python karena menyediakan pustaka standar yang kuat untuk mengelola operasi file dan direktori. Berikut adalah penjelasan untuk setiap bagian tugas beserta implementasinya.

1. Pembuatan dan Penghapusan File

   Kami membuat file baru dengan nama "data.txt", menuliskan beberapa data ke dalamnya, kemudian menghapus file tersebut setelah data berhasil dibaca.

\begin{python}
import os

# Pembuatan file baru dan menuliskan data ke dalamnya
with open('data.txt', 'w') as file:
    file.write('Ini adalah beberapa data contoh yang disimpan di file.')

# Membaca kembali isi file
with open('data.txt', 'r') as file:
    data = file.read()
    print("Isi file:", data)

# Menghapus file setelah dibaca
os.remove('data.txt')
print("File data.txt telah dihapus.")
\end{python}

2. Membaca dan Menulis File

   Setelah membuat file "data.txt", program menuliskan data string ke dalam file tersebut. Data tersebut kemudian dibaca dan ditampilkan ke layar.

\begin{python}
# Penulisan data ke file
with open('data.txt', 'w') as file:
    file.write('Ini adalah data tambahan yang akan disimpan di file.')

# Membaca data dari file
with open('data.txt', 'r') as file:
    content = file.read()
    print("Data yang dibaca dari file:", content)
\end{python}

3. Navigasi Direktori dan Pengelolaan Izin

   Kami membuat direktori baru dengan nama "my\_directory", memindahkan proses kerja ke dalam direktori tersebut, membuat file baru, dan mengubah izin file menjadi hanya dapat dibaca (read-only).

\begin{python}
# Membuat direktori baru
os.mkdir('my_directory')

# Berpindah ke direktori baru
os.chdir('my_directory')

# Membuat file baru di dalam direktori
with open('new_file.txt', 'w') as file:
    file.write('File baru di dalam direktori my_directory.')

# Mengubah izin file menjadi hanya dapat dibaca (read-only)
os.chmod('new_file.txt', 0o444)
print("File baru telah dibuat dengan izin read-only.")
\end{python}

\textbf{Penjelasan Kode:}

- Pada tugas pertama, kami menggunakan fungsi \texttt{open()} untuk membuat file "data.txt", kemudian menulis data ke dalam file tersebut. Setelah data berhasil dibaca, file dihapus menggunakan fungsi \texttt{os.remove()}.

- Pada tugas kedua, data tambahan ditulis ke dalam file "data.txt", dan kemudian dibaca kembali menggunakan mode \texttt{read}.

- Pada tugas ketiga, direktori baru "my\_directory" dibuat menggunakan fungsi \texttt{os.mkdir()}, dan program beralih ke direktori tersebut menggunakan \texttt{os.chdir()}. File baru kemudian dibuat di dalam direktori, dan izin file diubah menjadi hanya dapat dibaca menggunakan \texttt{os.chmod()}.

\textbf{Kesimpulan:}
Dengan menggunakan pustaka standar Python, kami berhasil mengimplementasikan operasi dasar pada sistem berkas seperti pembuatan dan penghapusan file, penulisan dan pembacaan data, serta pengelolaan direktori dan perubahan izin file. Tugas ini memberikan pemahaman yang lebih mendalam tentang bagaimana operasi file system dilakukan pada tingkat pemrograman.

\section{Conclusion}
The first half of the course introduced core operating system concepts, including process management, scheduling, multithreading, and file system access. These topics provided a foundation for more advanced topics to be covered in the second half of the course.

\begin{thebibliography}{}
    \bibitem{}
    Tutorialspoint. (n.d.). \textit{Operating system - Process control block}. Diakses pada 30 September 2024, dari \url{https://www.tutorialspoint.com/operating_system/os_process_control_block.htm}
    \bibitem{}
    Wikipedia contributors. (n.d.). Context switch. Dalam \textit{Wikipedia, The Free Encyclopedia}. Diakses pada 30 September 2024, dari \url{https://en.wikipedia.org/wiki/Context_switch} 
\end{thebibliography}

\end{document}